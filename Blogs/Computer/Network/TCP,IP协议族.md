TCP,IP协议族
---
#### 目录
- [TCP/IP协议族](#head1)
- [TCP连接](#head2)
	- [什么叫做连接](#head3)
	- [TCP连接的建立与关闭](#head4)
		- [3次握手](#head5)
		- [4次挥手](#head6)
	- [长连接](#head7)
		- [为什么要长连接](#head8)
		- [长连接的实现方式](#head9)

---
### <span id="head1">TCP/IP协议族</span>

概念：一系列协议所组成的一个网络分层模型

为什么要分层？因为网络的不稳定性

具体分层：

- 应用层（Application Layer）：HTTP、FTP、DNS
- 传输层（Transport Layer ）：
- 网络层（Internet Layer）：
- 数据链路层（Link Layer）：


层 | 英文名 | 协议 | 备注
---|---|---|---
应用层 | Application Layer | HTTP、FTP、DNS | 给出需要传输的数据
传输层 | Transport Layer | TCP、UDP | 将需要传输的数据分块，然后交给网络层，重传也是这里负责
网络层 | Internet Layer | IP | 负责传输，路由、寻址什么的
数据链路层 | Link Layer | 以太网、WiFi | 

### <span id="head2">TCP连接</span>

#### <span id="head3">什么叫做连接</span>

这里的连接是TCP连接，必须先建立连接，双方才能发送消息，不然不认识你，就会把你的消息丢掉。

#### <span id="head4">TCP连接的建立与关闭</span>

##### <span id="head5">3次握手</span>

![TCP连接三次握手](https://raw.githubusercontent.com/xfhy/Android-Notes/master/Images/TCP连接三次握手.png)


过程 | 具体描述 | 报文段信息 | 状态
---|---|---|---
第一次握手 | 客户端向服务器发送一个连接请求的报文段 | 同步标志位设为1：SYN=1；随机选择一个起始序号：seq=x；不携带数据；（因SYN位被设置为1的报文段不能携带数据，但要消耗一个序号）| 客户端进入「同步已发送」状态（SYN_SEND）（等待服务器的确认）
第二次握手 | 服务器收到请求连接报文段后，若同意建立连接，则向客户端发回连接确认的报文段（为该TCP连接分配TCP缓存、变量） | 同步标志位设为1：SYN-1；确认标志位设为1：ACK=1；随机选择一个起始序号：seq=y；确认号字段设为：ack=x+1；不携带数据（原因同上，但要消耗一个序号） | 服务器进入「同步已接收」状态（SYN_RCVD）
第三次握手 | 客户端收到确认报文段后，向服务器再次发出连接确认报文段（为该TCP连接分配TCP缓存、变量）| 确认标志位设为1：ACK=1；序号：seq=x+1；确认号字段设为ack=y+1；可携带数据（因SYN无需设为1，若不携带数据则不消耗序号） | 客户端、服务器端都进入已创建状态（ESTABLISHED）（可开始发送数据）

为什么只有三次握手才能确认双方的接收与发送能力是否正常，而两次却不可以（为什么需要三次握手）？

1. 第一次握手：客户端发送网络包，服务端收到了。这样服务端就能得出结论：客户端的发送能力、服务端的接收能力是正常的
2. 第二次握手：服务端发包，客户端收到了。这样客户端就能得出结论：服务端的接收、发送能力，客户端的接收、发送能力是正常的。不过此时服务器并不能确认客户端的接收能力是否正常
3. 第三次握手：客户端发包，服务端收到了。这样服务端就能得出结论：客户端的接收、发送能力正常，服务器自己的发送、接收能力也正常

**三次握手的作用：**

1. 确认双方的接收能力、发送能力是否正常
2. 指定自己的初始化序列号，为后面的可靠传输做准备
3. 防止服务器端因接收了早已失效的连接请求报文，从而一直等待客户端请求，最终导致形成死锁、浪费资源

##### <span id="head6">4次挥手</span>

在通信结束后，双方都可以释放连接，共需四次挥手

![TCP四次挥手](https://raw.githubusercontent.com/xfhy/Android-Notes/master/Images/TCP四次挥手.png)


过程 | 具体描述 | 报文段信息 | 状态
---|---|---|---
第一次挥手 | 客户端向服务器发送1个连接释放的报文段（停止再发送数据）| 终止控制位设为1：FIN=1；<br>报文段序号设为前面传送数据最后一个字节的序号加1：seq=u；<br>可携带数据<br>（FIN=1的报文即使不携带数据也消耗1个序号）| 客户端进入终止等待1状态（FIN-WAIT-1）（等待服务器的确认）
第二次挥手 | 服务器收到连接释放报文段后，则向客户端发回连接释放确认的报文段 | 确认标记位设为1：ACK=1；报文段序号 设为前面传送数据最后一个字节的序号加1：seq=v；确认号字段设为：ack=u+1；| 服务器进入关闭等待状态（CLOSE-WAIT）；客户端收到服务器的确认后，进入终止等待2状态（FIN-WAIT-2），等待服务器发出释放连接请求；至此，客户端->服务器的TCP连接已断开；即TCP连接处于半关闭状态；即客户端->服务器断开，但服务器->客户端未断开
第三次挥手 | 若服务器已无要向客户端发送数据，则发出释放连接的报文段 | 终止控制位 设为1：FIN=1；确认标记位设为1：ACK=1，报文段序号：seq=w；重复上次已发送的确认号字段，设为：ack=u+1；可携带数据（FIN=1的报文即时不携带数据也消耗1个序号） | 服务器端进入最后确认状态（LAST-ACK）
第四次挥手 | 客户端收到连接释放报文段后，则向服务器发回连接释放确认的报文段 | 确认标记位 设为1：ACK=1；报文段序号：seq=u+1；确认号字段 设为ack=w+1；可携带数据（FIN=1的报文即使不携带数据也消耗1个序号） | 客户端进入时间等待状态（TIME-WAIT），服务器进入 关闭状态（CLOSED）；此时TCP连接还未释放 ；须经过时间等待计时器设置的时间2MSL后，客户端才进入连接关闭状态（CLOSED）；即服务器进入关闭状态比客户端要早一些



#### <span id="head7">长连接</span>

##### <span id="head8">为什么要长连接</span>

移动网络并不在Internet中，而是在运营商的内网，并不具有真正的公网IP，因此当某个TCP连接在一段时间不通信之后，网关会出于网络性能考虑而关闭这条TCP连接和公网的连接通道，导致这个TCP端口不再能收到外部通信消息，即TCP连接被动关闭。

##### <span id="head9">长连接的实现方式</span>

心跳。即在一定间隔时间内，使用TCP连接发送超短无意义消息来让网关不能将自己定义为空闲连接，从而防止网关将自己的连接关闭。
