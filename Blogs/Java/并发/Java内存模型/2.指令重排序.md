指令重排序
---

### 什么是重排序

假设我们写了一个Java程序,包含一系列的语句,我们会默认期望这些语句的实际运行顺序和写的代码顺序一致.但实际上,编译器、JVM或者CPU都有可能处于优化等目的,对于实际指令执行顺序进行调整,这就是重排序.

**重排序的好处: 提高处理速度.** 重排序通过减少执行指令,从而提高整体的运行速度,这就是重排序带来的优化和好处.

### 重排序的3种情况

#### 1. 编译器优化

编译器(包括JVM,JIT编译器等)出于优化的目的,例如当前有了数据a,把对a的操作放到一起效率会更高,避免读取b后又返回来重新读取a的时间开销,此时在编译的过程中会进行一定程度的重排.重排序并不意味着可以任意排序,它需要保证重排序后,不改变单线程内的语义,否则如果能任意排序的话,程序早就逻辑混乱了.

#### 2. CPU重排序

CPU同样会有优化行为,这里的优化和编译器优化类似,都是通过乱序执行的技术来提高整体的执行效率.所以即使之前的编译器不发生重排,CPU也可能进行重排,我们在开发中,一定要考虑到重排序带来的后果.

#### 3. 内存的"重排序"

内存系统是不存在真正的重排序的,但是内存会带来看上去和重排序一样的效果.所以这里的"重排序"是加了双引号的.由于内存有缓存的存在,在JVM里表现为主存和本地内存,而主存和本地内存的内容可能不一致,所以这也会导致程序表现出乱序的行为.

举个例子,线程1修改了a的值,但是修改后没有来得及把新结果写会主存或者线程2没来得及读到最新的值,所以线程2看不懂刚才线程1对a的修改,此时线程2看到的a还是等于初始值.但是线程2缺却可能看到线程1修改a之后的代码执行效果,表面上看起来像是发生了重排序.