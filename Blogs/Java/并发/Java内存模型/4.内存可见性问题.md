内存可见性问题
---

#### synchronized也保证了可见性问题

synchronized不仅保证了临界区内最多同时只有一个线程执行操作,同时还保证了在前一个线程释放锁之后,所做的所有修改,都能被获得同一个锁的下一个线程所看到,也就是能读取到最新的值. 因为如果其他线程看不到之前的修改,依然也会发生线程安全问题.

#### CPU有多级缓存,导致读的数据过期

线程间对于共享变量的可见性问题,并不是直接由多核引起的,而是由L3缓存、L2缓存、L1缓存,也就是**多级缓存"引起的. 每个核心在读取数据时,都会将数据从内存一层层往上读取,同样,后续对于数据的修改也是先写入到自己的L1缓存中,然后等待时机再逐层往下同步,直到最终刷回内存.

### JMM的抽象: 主内存和工作内存

#### 主内存和工作内存

![](https://raw.githubusercontent.com/xfhy/Android-Notes/master/Images/%E4%B8%BB%E5%86%85%E5%AD%98%E5%92%8C%E5%B7%A5%E4%BD%9C%E5%86%85%E5%AD%98.png)

每个线程只能够直接接触到工作内存,无法直接操作主内存,而工作内存中所保存的正是主内存的共享变量的副本,主内存和工作内存之间的通信是由JMM控制的.

#### 主内存和工作内存的关系

JMM规定:

1. 所有的变量都存储在主内存中,同时每个线程拥有自己独立的工作内存,而工作内存中的变量的内容是主内存中该变量的拷贝.
2. 线程不能直接读/写主内存中的变量,但可以操作自己工作内存中的变量,然后再同步到主内存中,这样其他线程就可以看到本次修改.
3. 主内存是由多个线程所共享的,但线程间不共享各自的工作内存,如果线程间需要通信,则需要借助主内存中转来完成.



