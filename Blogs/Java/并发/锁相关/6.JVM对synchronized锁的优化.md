JVM对synchronized锁进行了哪些优化
---

> 在JDK 1.6中HotSopt虚拟机对synchronized内置锁的性能进行了很多优化,包括自适应的自旋、锁消除、锁粗化、偏向锁、轻量级锁等.

### 自适应的自旋锁

> 自旋,就是不释放CPU,一直循环尝试获取锁.自旋的缺点在于如果自旋时间过长,那么性能开销是很大的.

在JDK1.6中加入了自适应的自旋锁来解决长时间自旋的问题.自适应意味着自旋的时间不再固定,而是会根据最近自旋尝试的成功率、失败率,以及当前锁的拥有者的状态等多种因素来共同决定.自旋的持续时间是变化的,自旋锁变聪明了.

### 锁消除

监测到不可能存在共享数据竞争的锁进行消除.

比如,经过逃逸分析之后,如果发现某些对象不可能被其他线程访问到,那么就可以把它们当成栈上数据,栈上数据由于只有本线程可以访问,自然是线程安全的,也就是无需加锁,所以会把这样的锁自动去除掉.

例如，我们的 StringBuffer 的 append 方法如下所示：
```java
@Override
public synchronized StringBuffer append(Object obj) {
    toStringCache = null;
    super.append(String.valueOf(obj));
    return this;
}
```
从代码中可以看出，这个方法是被 synchronized 修饰的同步方法，因为它可能会被多个线程同时使用。

但是在大多数情况下，它只会在一个线程内被使用，如果编译器能确定这个 StringBuffer 对象只会在一个线程内被使用，就代表肯定是线程安全的，那么我们的编译器便会做出优化，把对应的 synchronized 给消除，省去加锁和解锁的操作，以便增加整体的效率.

### 锁粗化

如果我们释放了锁,紧接着什么都没做,又重新获取锁,例如:

```java
public void lockCoarsening() {
    synchronized (this) {
        //do something
    }
    synchronized (this) {
        //do something
    }
    synchronized (this) {
        //do something
    }
}
```

其实这种释放和重新获取锁是完全没必要的,如果把同步区域扩大,在最开始加一把锁,并且在最后才解锁,就可以把中间这些无意义的解锁和加锁的过程消除,相当于把几个synchronized块合并为一个较大的同步块.这样做的好处在于在线程执行这些代码时,就无须频繁申请与释放锁了,减少了性能开销.

锁粗化不适用于循环的场景,因为可能导致其他线程长时间无法获得锁(循环完了才解锁).

### 偏向锁/轻量级锁/重量级锁

> 这3种锁特指synchronized锁的状态,通过在对象头中的mark word来表明锁的状态

**偏向锁**

对于偏向锁,它的思想是自始至终,对于这把锁都不存在竞争,就没必要上锁,只是打个标记就行了.一个对象在被初始化之后,如果还没任何线程来获取它的锁时,它就是可偏向的,当有第一个线程来访问它尝试获取锁的时候,它就记录下来这个线程,如果后面尝试获取锁的线程正是这个偏向锁的拥有者,就可以直接获取锁,开销很小.

**轻量级锁**

synchronized中的代码块在很多情况下,其实是被多个线程交替执行的,并不存在实际的竞争,用CAS(乐观锁的一种实现)就可以解决.这种情况下,重量级锁是没必要的.轻量级锁指当锁原来是偏向锁的时候,被另一个线程所访问,说明存在竞争,那么偏向锁就会升级为轻量级锁,线程会通过自旋的方式尝试获取锁,不会阻塞.

**重量级锁**

这种锁利用操作系统的同步机制实现,所以开销比较大.当多个线程直接有实际竞争,并且锁竞争时间比较长的时候,此时偏向锁和轻量级锁都不能满足需求,锁就会膨胀为重量级锁.重量级锁会让其他申请却拿不到锁的线程进入阻塞状态.

---------

**小结**

从无锁到偏向锁,再到轻量级锁,最后到重量级锁.偏向锁性能最好,避免了CAS操作.而轻量级锁利用自旋和CAS避免了重量级锁带来的线程阻塞和唤醒,性能中等.重量级锁则会把获取不到锁的线程阻塞,性能最差.