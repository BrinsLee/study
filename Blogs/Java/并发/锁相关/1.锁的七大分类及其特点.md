锁的七大分类及其特点
---

> 一把锁可能同时占有多个标准,符合多种分类.比如ReentrantLock既是可中断锁,又是可重入锁.

根据分类标准,可以把锁分为以下7大类别

- 偏向锁/轻量级锁/重量级锁
- 可重入锁/非可重入锁
- 共享锁/独占锁
- 公平锁/非公平锁
- 悲观锁/乐观锁
- 自旋锁/非自旋锁
- 可中断锁/不可中断锁

### 偏向锁/轻量级锁/重量级锁

> 这三种锁**特指synchronized锁的状态,通过在对象头中的mark word来表明锁的状态**.

#### 偏向锁

**如果自始至终,对于这把锁都不存在竞争,那么其实就没必要上锁,只需要打个标记就行了,这就是偏向锁的思想**.一个对象被初始化后,还没有任何线程来获取它的锁时,那么它就是可偏向的,当有第一个线程来访问它并尝试获取锁的时候,它就将这个线程记录下来,以后如果尝试获取锁的线程正是偏向锁的拥有者,就可以直接获得锁,开销很小,性能最好.

#### 轻量级锁

JVM开发者发现在很多情况下,synchronized中的代码是被多个线程交替执行的,而不是同时执行的,也就是说并不存在实际的竞争,或者是只有短时间的锁竞争,**用CAS就可以解决(当有一个线程竞争获取锁时,由于该锁已经是偏向锁,当发现对象头Mark Word中的线程ID不是自己的线程ID,就会进行CAS操作获取该锁.)**,这种情况下,用完全互斥的重量级锁是没必要的.轻量级锁是指当锁原来是偏向锁的时候,被另一个线程访问,说明**存在竞争,那么偏向锁就会升级为轻量级锁,线程会通过自旋的形式尝试获取锁**,而不会陷入阻塞.

#### 重量级锁

重量级锁是互斥锁,它是利用操作系统的同步机制实现的,所以开销相对比较大.当多个线程直接有实际竞争,且锁竞争时间长的时候,轻量级锁不能满足需求,锁就会膨胀为重量级锁.重量级锁会让其他申请却拿不到锁的线程进入阻塞状态.

锁的升级路径: 无锁->偏向锁->轻量级锁->重量级锁

**小结: 综上,偏向锁性能最好,可以避免执行CAS操作.而轻量级锁利用自旋和CAS避免了重量级锁带来的线程阻塞和唤醒,性能中等.重量级锁则会把获取不到锁的线程阻塞,性能最差**

### 可重入锁/非可重入锁

可重入锁指的是线程当前已经持有这把锁了,能在不释放这把锁的情况下,再次获取这把锁.同理,不可重入锁值的是虽然线程当前持有了这把锁,但是如果想再次获取这把锁,也必须要先释放锁后才能再次尝试获取.

对于可重入锁而言,最典型的就是ReentrantLock了,正如它的名字一样,reentrant的意思就是可重入,它也是Lock接口最主要的一个实现类.

### 共享锁/独占锁

共享锁指的是同一把锁可以被多个线程同时获得,而独占锁指的是这把锁只能同时被一个线程获得.读写锁,就最好地诠释了共享锁和独占锁的理念.读写锁中的读锁,是共享锁,而写锁是独占锁.读锁可以被同时读,可以同时被多个线程持有,而写锁最多只能同时被一个线程持有.

### 公平锁/非公平锁

公平锁的公平的含义在于如果线程现在拿不到这把锁,那么线程就都会进入等待,开始排队,在等待队列里等待时间长的线程会优先拿到这把锁,有点像先来先得.而非公平锁就不那么完美了,它会在一定情况下,忽略掉已经在排队的线程,发送插队现象.

### 悲观锁/乐观锁

悲观锁的概念是在获取资源之前,必须先拿到锁,以便达到独占的状态,当前线程在操作资源的时候,其他线程由于不能拿到锁,所以其他线程不能来影响我.

乐观锁则恰恰相反,它并不要求在获取资源前拿到锁,也不会锁住资源.每次拿数据的时候都认为别的线程不会修改这个数据,但是在更新的时候会判断一下在此期间别的线程有没有修改过数据(如果被修改过,则会放弃这次修改,并选择报错、重试等策略).乐观锁适用于读操作多的场景,这样可以提高程序的吞吐量,在Java中java.util.concurrent.atomic包下面的原子变量就是使用了乐观锁的一种实现方式CAS实现.

典型:

- 悲观锁: synchronized关键字和Lock接口
- 乐观锁: 原子类

虽然悲观锁确实会让得不到锁的线程阻塞,但是这种开销是固定的.悲观锁的原始开销确实要高于乐观锁,但是特点是一劳永逸,就算一直拿不到锁,也不会对开销造成额外的影响. 反观乐观锁虽然一开始的开销比悲观锁小,但是如果一直拿不到锁,或者并发量大,竞争激烈,导致不停重试,那么消耗的资源也会越来越多,甚至开销超过悲观锁.

**使用场景**

悲观锁适用于并发写入多、临界区代码复杂、竞争激烈等场景,这种场景下悲观锁可以避免大量的无用的反复尝试等消耗.

乐观锁适用于大部分是读取,少部分是修改的场景,也适用虽然读写很多,但是并发并不激烈的场景.在这些场景下,乐观锁不加锁的特点能让性能大幅提高.

### 自旋锁/非自旋锁

自旋锁的概念是如果线程现在拿不到锁,并不直接陷入阻塞或者释放CPU资源,而是开始利用循环,不停地尝试获取锁,这个循环过程被称为自旋.相反,非自旋锁的概念就是没有自旋的过程,如果拿不到锁就直接放弃,或者进行其他的逻辑处理,例如去排队、陷入阻塞等.

### 可中断锁/不可中断锁

在Java中synchronized关键字修饰的锁代表的是不可中断锁,一旦线程申请了锁,就没有回头路了,只能等到拿到锁以后才能进行其他的逻辑处理.而我们的ReentrantLock是一种典型的可中断锁,例如使用lockInterruptibly方法在获取锁的过程中,突然不想获取了,那么也可以在中断之后去做其他的事情,不需要一直傻等到获取到锁才离开.