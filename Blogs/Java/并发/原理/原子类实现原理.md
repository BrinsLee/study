原子类实现原理
---

原子类既是指Java中的Atomic类,比如AtomicInteger、AtomicLong、AtomicStampedReference、AtomicReference等,都是通过CAS来做的.

CAS即比较并替换,它是通过硬件来保证操作的原子性.去修改某个值,修改失败则重试.

在Java中,UnSafe类提供了对CAS的简单封装,Atomic类内部也都是使用UnSafe类来做的,UnSafe类是可以直接操作内存的,一般在应用程序中是不能使用的,它是由启动器加载的.UnSafe类提供了一系列的compareAndSwapXxx方法,它们都是native方法.除此之外,UnSafe还有一对park/unpark阻塞唤醒线程的方法,LockSupport便是对它的包装.

CAS存在的问题也比较多,但是现在基本上都有解决方案.

1. 首先是ABA问题(中途有其他线程修改了A的值,但是在结束之前又改回去了,中间一小部分时间的数据是不对的,根据业务场景判断这种是否需要处理),解决思路就是加一个版本号,可以使用AtomicStampedReference来解决.
2. 其次是循环时间长开销大,这个问题的解决可以参考Java8新增的LongAdder类.在高并发场景下,大量线程会同时去竞争更新同一个原子变量,但是由于同时只有一个线程CAS操作会成功,这就造成了大量线程竞争失败后自旋继续尝试,严重损耗CPU,这时候LongAdder的思路就是将一个变量分别为多个变量,让多个线程去竞争多个资源,也就是把long值分为一个base加上一个Cell数组,最后取值时就是base加上多个Cell的值.
3. CAS操作是针对一个变量的,如果对多个变量操作,可以: 1. 加锁来解决  2. 封装成对象类解决
