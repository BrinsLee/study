
### synchronized使用

synchronized可以用来修饰3个层面:

- 修饰实例方法
- 修饰静态类方法
- 修饰代码块


注意:

- 无论synchronized关键字加载方法上还是对象上,如果它作用的对象是非静态的,则它取得的锁是对象;如果synchronized作用的对象是一个静态方法或一个类,则它取得的锁是对类,该类所有的对象同一把锁
- 每个对象只有一个锁(lock)与之相关联,谁拿到这个锁谁就可以运行它所控制的那段代码
- 实现同步是要很大的系统开销作为代价的,甚至可能造成死锁,所以尽量避免无谓的同步控制

小结: **对于普通方法,锁是当前实例对象;对于静态方法,锁是当前类的Class对象;对于同步代码块,锁是括号里配置的对象.**

### synchronized原理

**锁方法**: 在编译方法的时候`ACCESS_FLAGS`加一个`ACC_SYNCHRONIZED`标志位,`ACCESS_FLAGS`是访问标志位,除此之外还有常见的public,private,static等.当虚拟机访问一个被标记位`ACC_SYNCHRONIZED`的方法时,会自动在方法的开始和结束(或异常)位置添加monitorenter和monitorexit指令.

**锁代码块**: 在代码块的前后增加一对monitorenter和monitorexit指令. 

在Java 1.6时,synchronized做了大量优化,引入了锁自旋,轻量级锁和偏向锁.此时锁有四种状态,分别是无锁、偏向锁、轻量级锁和重量级锁.这几个状态会随着竞争情况逐渐升级,锁可以升级但不能降级,不过锁降级确实会发生,只不过概率很小,当JVM进入安全点的时候,会检测是否有闲置的Monitor,然后试图进行降级.

在讲四种状态之前,先了解一下对象头.synchronized用的锁的信息是存放在Java对象头的Mard Word标记字段中,它里面保存了对象的HashCode、分代年龄和锁标志位.锁标志位用两个bit表示,00表示轻量级锁,10表示重量级锁;01表示偏向锁和无锁,它们两个再用一个bit表示是否是偏向锁.

先说一下偏向锁,为什么要有偏向锁? 在大多数情况下,锁不仅不存在多线程竞争,而且总是由同一个线程多次获得,为了让线程获得锁的代价更低而引入了偏向锁.当一个线程访问同步块并获取锁时,会在对象头里记录锁偏向的线程ID,下次该线程再次进入只需要判断线程ID就可以了.

然后是轻量级锁,当有一个线程竞争获取锁时,由于该锁已经是偏向锁,当发现对象头Mark Word中的线程ID不是自己的线程ID,就会进行CAS操作获取该锁.如果获取到了就替换线程ID,继续保持偏向锁状态,如果获取不到就自旋一段时间再次获取,也就是自旋锁,如果在指定次数没有成功,就会膨胀为重量级锁,当前线程阻塞掉.默认次数是10,当然,后面出了自适应自旋锁,会根据上次自旋的次数来设置.因为长时间的自旋会消耗CPU,所以会有限制次数.轻量级锁适用于线程交替执行同步块的场景,绝大部分的锁在整个同步周期都不存在长时间的竞争.


小结:其中偏向锁和轻量级锁都是通过自旋等技术避免真正的加锁，而重量级锁才是获取锁和释放锁，重量级锁通过对象内部的监视器（ObjectMonitor）实现，其本质是依赖于底层操作系统的 Mutex Lock 实现，操作系统实现线程之间的切换需要从用户态到内核态的切换，成本非常高