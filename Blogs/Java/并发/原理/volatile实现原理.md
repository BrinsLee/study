volatile实现原理
---

volatile保证了共享变量的可见性和有序性.

- 可见性是指一个线程修改了共享变量,另一个线程可以立即感知到
- 有序性是指禁止编译器或处理器重新排序

**可见性原理**: 当对volatile变量进行写操作的时候,JVM会向处理器发送一条lock前缀的指令,这个lock指令第一个作用是将这个缓存中的变量回写到系统主存中;第二个作用是这个写内存的操作会使其他CPU里缓存了该内存地址的数据无效.但是就算回写到内存,如果其他处理器缓存的值还是旧的,还是有问题,为了保证各个处理器的缓存是一致的,就会实现一致性协议,即每个处理器通过嗅探在总线上传播的数据来检查自己缓存的值是不是过期了,如果内存地址被修改就会把当前处理器的缓存行设置为无效状态,当处理器对这个数据进行操作的时候,就会重新拉一份新的值.

**有序性原理**: 有序性是通过内存屏障来实现的,具体实现:
1. 在volatile写操作的的前面插入一个StoreStore屏障,保障volatile写操作不会和之前的写操作重排序
2. 在volatile写操作的后面插入一个StoreLoad屏障,保障volatile写操作不会和之后的读操作重排序
3. 在volatile读操作的后面插入一个LoadLoad屏障+LoadSore屏障,保证volatile读操作不会和之后的读操作,写操作重排序